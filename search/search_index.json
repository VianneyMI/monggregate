{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcca Monggregate","text":""},{"location":"#overview","title":"\ud83d\udccb Overview","text":"<p>Monggregate is a library that aims at simplifying usage of MongoDB aggregation pipelines in Python. It's a lightweight QueryBuilder for MongoDB aggregation pipelines based on pydantic and compatible with all mongodb drivers and ODMs.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83d\udd04 Provides an Object Oriented Programming (OOP) interface to the aggregation pipeline.</li> <li>\ud83c\udfaf Allows you to focus on your requirements rather than MongoDB syntax.</li> <li>\ud83d\udcda Integrates all the MongoDB documentation and allows you to quickly refer to it without having to navigate to the website.</li> <li>\ud83d\udd0d Enables autocompletion on the various MongoDB features.</li> <li>\ud83d\udd17 Offers a pandas-style way to chain operations on data.</li> <li>\ud83d\udcbb Mimics the syntax of your favorite tools like pandas</li> </ul>"},{"location":"#installation","title":"\ud83d\udce5 Installation","text":"<p>\ud83d\udca1 The package is available on PyPI:</p> <pre><code>pip install monggregate\n</code></pre>"},{"location":"#usage","title":"\ud83d\ude80 Usage","text":"<p>\ud83d\udcd8 The below examples reference the MongoDB sample_mflix database</p>"},{"location":"#basic-pipeline-usage","title":"\ud83d\udd30 Basic Pipeline usage","text":"<pre><code>import os\nfrom dotenv import load_dotenv \nimport pymongo\nfrom monggregate import Pipeline, S\n# Creating connexion string securely\n# You need to create a .env file with your password\nload_dotenv(verbose=True)\nMONGODB_URI = os.environ[\"MONGODB_URI\"] \n# Connect to your MongoDB cluster:\nclient = pymongo.MongoClient(MONGODB_URI)\n# Get a reference to the \"sample_mflix\" database:\ndb = client[\"sample_mflix\"]\n# Creating the pipeline\npipeline = Pipeline()\n# The below pipeline will return the most recent movie with the title \"A Star is Born\"\npipeline.match(\ntitle=\"A Star Is Born\"\n).sort(\nby=\"year\"\n).limit(\nvalue=1\n)\n# Executing the pipeline\ncurosr = db[\"movies\"].aggregate(pipeline.export())\n# Printing the results\nresults = list(curosr)\nprint(results)\n</code></pre>"},{"location":"#advanced-usage-with-mongodb-operators","title":"\ud83c\udf1f Advanced Usage, with MongoDB Operators","text":"<pre><code>import os\nfrom dotenv import load_dotenv \nimport pymongo\nfrom monggregate import Pipeline, S\n# Creating connexion string securely\nload_dotenv(verbose=True)\nMONGODB_URI = os.environ[\"MONGODB_URI\"]\n# Connect to your MongoDB cluster:\nclient = pymongo.MongoClient(MONGODB_URI)\n# Get a reference to the \"sample_mflix\" database:\ndb = client[\"sample_mflix\"]\n# Creating the pipeline\npipeline = Pipeline()\npipeline.match(\nyear=S.type_(\"number\") # Filtering out documents where the year field is not a number\n).group(\nby=\"year\",\nquery = {\n\"movie_count\":S.sum(1), # Aggregating the movies per year\n\"movie_titles\":S.push(\"$title\")\n}\n).sort(\nby=\"_id\",\ndescending=True\n).limit(10)\n# Executing the pipeline\ncursor = db[\"movies\"].aggregate(pipeline.export())\n# Printing the results\nresults = list(cursor)\nprint(results)\n</code></pre>"},{"location":"#even-more-advanced-usage-with-expressions","title":"\ud83d\udd25 Even More Advanced Usage with Expressions","text":"<pre><code>import os\nfrom dotenv import load_dotenv \nimport pymongo\nfrom monggregate import Pipeline, S\n# Creating connexion string securely\nload_dotenv(verbose=True)\nMONGODB_URI = os.environ[\"MONGODB_URI\"] \n# Connect to your MongoDB cluster:\nclient = pymongo.MongoClient(MONGODB_URI)\n# Get a reference to the \"sample_mflix\" database:\ndb = client[\"sample_mflix\"]\n# Using expressions\ncomments_count = S.size(S.comments)\n# Creating the pipeline\npipeline = Pipeline()\npipeline.lookup(\nright=\"comments\",\nright_on=\"movie_id\",\nleft_on=\"_id\",\nname=\"comments\"\n).add_fields(\ncomments_count=comments_count\n).match(\nexpression=comments_count&gt;2\n).limit(1)\n# Executing the pipeline\ncursor = db[\"movies\"].aggregate(pipeline.export())\n# Printing the results\nresults = list(cursor)\nprint(results)\n</code></pre>"},{"location":"#going-further","title":"\ud83d\udd0d Going Further","text":"<ul> <li>\ud83d\udcda Check out the full documentation for more examples.</li> <li>\ud83d\udcdd Check out this medium article.</li> </ul>"},{"location":"api/","title":"Api","text":"<p>:::monggregate.pipeline    options:      annotations_path: source</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#0210-2024-04-17","title":"\ud83d\ude80 0.21.0 - 2024-04-17","text":"Details  Identical to 0.21.0b1."},{"location":"changelog/#0210b1-2024-04-17","title":"\ud83e\uddea 0.21.0b1 - 2024-04-17","text":"Details \ud83d\udcd6 Documentation <p>Improved docstrings in stages and operators.</p>"},{"location":"changelog/#0210b0-2024-01-30","title":"\ud83e\uddea 0.21.0b0 - 2024-01-30","text":"Details \u2728 New Features <p>Implemented <code>VectorSearch</code> pipeline stage.</p>"},{"location":"changelog/#0200-2024-01-27","title":"\ud83d\ude80 0.20.0 - 2024-01-27","text":"Details \ud83d\udc1b Bug Fixes <p>Fixed bug in <code>Search</code> where some arguments were not properly forwarded to the appropriate operators.</p> \ud83d\udcd6 Documentation <p>Added documentation for <code>search</code> and <code>search_meta</code> pipeline stages.</p>"},{"location":"changelog/#0191-2023-12-28","title":"\ud83d\ude80 0.19.1 - 2023-12-28","text":"Details \ud83d\udc1b Bug Fixes <p>Fixed build, packaging and release process.</p>"},{"location":"changelog/#0190-2023-12-20","title":"\ud83d\ude80 0.19.0 - 2023-12-20","text":"Details  Failed attempt to fix previously broken release."},{"location":"changelog/#0180-2023-11-12","title":"\ud83d\ude80 0.18.0 - 2023-11-12","text":"Details \u26a0\ufe0f This release is not available on PyPI as it was broken. \ud83d\udc1b Bug Fixes <p>Fixed bug preventing use of <code>Compound</code> operator with <code>Search</code> and <code>SearchMeta</code> classes.</p> \u2728 New Features <ul> <li>Pipelinized <code>Search</code> and <code>SearchMeta</code> classes. Complex expressions can now be built step by step by chaining operators.</li> <li>Updated <code>search</code> method in <code>Pipeline</code> class to ease the use of search stages.</li> <li>Clarified and simplified faceted search.</li> </ul> \u267b\ufe0f Refactoring <ul> <li>Use operators rather than statement in <code>Compound</code> class.</li> <li>Factorized <code>Search</code> and <code>SearchMeta</code> classes by creating a <code>SearchBase</code> class.</li> <li>Use <code>CountOptions</code> rather than raw dicts.</li> <li>Created <code>AnyStage</code> union type.</li> </ul> \ud83d\udcd6 Documentation <p>Spelling and grammar fixes.</p>"},{"location":"changelog/#0170-2023-10-26","title":"\ud83d\ude80 0.17.0 - 2023-10-26","text":"Details \ud83d\udcd6 Documentation <p>First version of the documentation \ud83c\udf7e!</p>"},{"location":"changelog/#0162-2023-09-17","title":"\ud83d\ude80 0.16.2 - 2023-09-17","text":"Details \ud83d\udc1b Bug Fixes <p>Allow use of iterables and dicts to group by in <code>Group</code> class and pipeline group function.</p>"},{"location":"changelog/#0161-2023-09-08","title":"\ud83d\ude80 0.16.1 - 2023-09-08","text":"Details \ud83d\udc1b Bug Fixes <p>Fixed <code>replace_root</code> by passing document argument to <code>ReplaceRoot</code> class.</p>"},{"location":"changelog/#0160-2023-08-29","title":"\ud83d\ude80 0.16.0 - 2023-08-29","text":"Details \u2728 New Features <ul> <li>Created <code>S</code> object (represents <code>$</code> sign since it is not a valid variable name in Python) to store all MongoDB operators and to create references to fields.</li> <li>Created <code>SS</code> object (represents <code>$$</code>) to store aggregation variables and references to user variables.</li> <li>Interfaced new operators: <code>add</code>, <code>divide</code>, <code>multiply</code>, <code>pow</code>, <code>subtract</code>, <code>cond</code>, <code>if_null</code>, <code>switch</code>, <code>millisecond</code>, <code>date_from_string</code>, <code>date_to_string</code>, <code>type_</code>.</li> <li>Integrated new operators in <code>Expressions</code> class.</li> </ul> \u267b\ufe0f Refactoring <ul> <li>Redefined <code>Expressions</code> completely. Simplified and clarified how they can be used.</li> <li>Removed index module from the root of the package (<code>monggregate.index.py</code> \u2192 \u2205).</li> <li>Removed expressions subpackage (<code>monggregate.expression</code> \u2192 \u2205).</li> <li>Moved expressions fields module to the root (<code>monggregate.expressions.fields.py</code> \u2192 <code>monggregate.fields.py</code>).</li> <li>Removed expressions aggregation_variables module (<code>monggregate.expression.aggregation_variables.py</code> \u2192 \u2205).</li> <li>Moved enums to more relevant locations (e.g., <code>OperatorEnum</code> is now in <code>monggregate.operators.py</code>).</li> </ul> \ud83d\udca5 Breaking Changes <ul> <li>Operators now return Python objects rather than expressions/statements.</li> Note: The wording might change for clarification purposes.   \"statement\" might be renamed \"expression\" and \"resolve\" might be renamed \"express\".   Some argument names in operators might need to be renamed. <li>Expressions subpackage has been restructured with some parts being removed.</li> </ul> \ud83d\udcd6 Documentation <p>Updated README to reflect changes in the package, focusing on the recommended usage and clarifying MongoDB operators.</p>"},{"location":"changelog/#0150-2023-08-09","title":"\ud83d\ude80 0.15.0 - 2023-08-09","text":"Details \ud83d\udc1b Bug Fixes <ul> <li>Fixed bug in <code>Search.from_operator()</code> classmethod due to recent change in operator type in <code>Search</code> class.</li> <li>Fixed misspelled operators in constructors map in <code>Search</code> class.</li> <li>Fixed missing aliases and missing kwargs reduction in some <code>Search</code> operators.</li> </ul>"},{"location":"changelog/#0141-2023-08-06","title":"\ud83d\ude80 0.14.1 - 2023-08-06","text":"Details \ud83d\udc1b Bug Fixes <p>Fixed autocompletion.</p> \u267b\ufe0f Refactoring <p>Import pydantic into <code>base.py</code> and use <code>base.py</code> to access pydantic features.</p>"},{"location":"changelog/#0140-2023-07-23","title":"\ud83d\ude80 0.14.0 - 2023-07-23","text":"Details \u2b06\ufe0f Upgrades <p>Made package compatible with Pydantic V2.</p> \u267b\ufe0f Refactoring <ul> <li>Used an import trick to still use Pydantic V1 even in environments using Pydantic V2.</li> <li>Centralized pydantic import into <code>base.py</code> to avoid having to use import trick in multiple files.</li> </ul> \ud83d\udcd6 Documentation <ul> <li>Updated README to better reflect current state of the package.</li> <li>Started a changelog! \ud83c\udf7e</li> <li>Major improvements to documentation.</li> </ul>"},{"location":"changelog/#what-about-previous-versions","title":"What about previous versions?","text":"<p>Prior to 0.14.0, the changelog was not kept.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We are actively looking for new contributors and maintainers to help us.</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>If you find a bug or have feature suggestions please raise an issue.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>We welcome pull requests from everyone. Follow the steps below to contribute to this project. The maintainers currently use GitHub to handle the roadmap of the project. So if you want to contribute to the code base, you can either:</p> <ul> <li>create an issue to start a discussion about a feature idea or a bug</li> <li>address an issue already listed in our backlog</li> </ul>"},{"location":"contributing/#new-to-open-source","title":"New to Open Source?","text":"<p>Please check out this article to help you get started.</p>"},{"location":"how-to/create-or-update-a-collection/","title":"Creating and Updating Collections in MongoDB","text":"<p>This guide demonstrates how to create a new collection from an existing one and update existing collections using MongoDB's aggregation framework with monggregate.</p> <p>Like in the previous how-to guide, we will use the <code>listingsAndReviews</code> collection from the <code>sample_airbnb</code> database.</p>"},{"location":"how-to/create-or-update-a-collection/#use-case-normalizing-data-with-collection-operations","title":"Use Case: Normalizing Data with Collection Operations","text":"<p>In this example, we'll implement a common database normalization pattern: separating embedded documents into their own collection while maintaining relationships between the collections.</p>"},{"location":"how-to/create-or-update-a-collection/#our-goal","title":"Our Goal","text":"<p>We want to extract all reviews from the <code>listingsAndReviews</code> collection into a separate <code>reviews</code> collection while maintaining the relationship between listings and their reviews.</p> <p>This separation provides several benefits: - Improved query performance when working with review data independently - Reduced document size in the listings collection - Better data organization following database normalization principles</p>"},{"location":"how-to/create-or-update-a-collection/#implementation","title":"Implementation","text":""},{"location":"how-to/create-or-update-a-collection/#step-1-creating-the-new-reviews-collection","title":"Step 1: Creating the New Reviews Collection","text":"<p>First, we'll extract all reviews into their own collection using an aggregation pipeline:</p> <pre><code># /!\\    /!\\    /!\\\n# Imports\n# and boilerplate code\n# to get the db object\n# are not included\n# /!\\    /!\\    /!\\\nfrom monggregate import Pipeline\n# Building the pipeline\nreviews = \"reviews\"\npipeline = Pipeline()\npipeline.unwind(\nreviews           # Separate each review into individual documents\n).replace_root(\nreviews           # Make each review the root document\n).out(\nreviews           # Output to a new \"reviews\" collection\n)\n# Executing the pipeline\ndb[\"listingsAndReviews\"].aggregate(pipeline=pipeline.export())\n# This pipeline won't output anything as the result is stored in the new collection\n</code></pre> <p>The pipeline above: 1. Uses <code>$unwind</code> to deconstruct the reviews array into individual documents 2. Uses <code>$replaceRoot</code> to promote each review to become the root document 3. Uses <code>$out</code> to save the results to a new \"reviews\" collection</p> <p>After this operation, the reviews exist in both the original <code>listingsAndReviews</code> collection and our new <code>reviews</code> collection.</p>"},{"location":"how-to/create-or-update-a-collection/#step-2-updating-the-listings-collection","title":"Step 2: Updating the Listings Collection","text":"<p>Next, we'll modify the listings collection to replace full review documents with just their IDs, creating a reference-based relationship:</p>"},{"location":"how-to/create-or-update-a-collection/#option-1-create-a-new-collection-and-drop-the-old-one","title":"Option 1: Create a new collection and drop the old one","text":"<pre><code># /!\\    /!\\    /!\\\n# Imports\n# and boilerplate code\n# to get the db object\n# are not included\n# /!\\    /!\\    /!\\\nfrom monggregate import Pipeline\n# Useful variables\nnew_field = \"review_ids\"\nnew_collection = \"listings\"\nold_collection = \"listingsAndReviews\"\n# Building the pipeline\npipeline = Pipeline()\n# Create a new collection with references instead of embedded reviews\npipeline.add_fields(\n{new_field: \"$reviews._id\"}    # Extract review IDs into a temporary field\n).add_fields(\n{\"reviews\": f\"${new_field}\"}   # Replace reviews array with array of IDs\n).unset(\nnew_field                      # Remove the temporary field\n).out(\nnew_collection                 # Output to new \"listings\" collection\n)\n# Execute pipeline and then remove old collection\ndb[old_collection].aggregate(pipeline=pipeline.export())\ndb.drop_collection(old_collection)\n</code></pre>"},{"location":"how-to/create-or-update-a-collection/#option-2-update-the-existing-collection-in-place","title":"Option 2: Update the existing collection in place","text":"<pre><code># Option 2: Update the existing collection\npipeline = Pipeline()\npipeline.add_fields(\n{new_field: \"$reviews._id\"}    # Extract review IDs into a temporary field\n).add_fields(\n{\"reviews\": f\"${new_field}\"}   # Replace reviews array with array of IDs  \n).unset(\nnew_field                      # Remove the temporary field\n).out(\nold_collection                 # Overwrite the existing collection\n)\n# Execute pipeline and optionally rename the collection\ndb[old_collection].aggregate(pipeline=pipeline.export())\ndb[old_collection].rename(new_collection)\n</code></pre> <p>After performing either option, you'll have two properly normalized collections: - <code>reviews</code>: Contains individual review documents with their own _id - <code>listings</code>: Contains listings with references to reviews (just the IDs)</p>"},{"location":"how-to/create-or-update-a-collection/#working-with-the-new-collections","title":"Working with the New Collections","text":""},{"location":"how-to/create-or-update-a-collection/#querying-individual-reviews","title":"Querying Individual Reviews","text":"<p>You can now easily query reviews directly without loading entire listing documents:</p> <pre><code># Find all reviews by a specific reviewer\nreviewer_name = \"John\"\ndb.reviews.find({\"reviewer_name\": reviewer_name})\n</code></pre>"},{"location":"how-to/create-or-update-a-collection/#retrieving-listings-with-their-reviews","title":"Retrieving Listings with Their Reviews","text":"<p>To get listings with their full review data, you'll need to perform a join operation using the <code>$lookup</code> stage:</p> <pre><code>from monggregate import Pipeline\npipeline = Pipeline()\npipeline.lookup(\nright=\"reviews\",          # Target collection\nleft_on=\"reviews\",        # Field in listings containing review IDs\nright_on=\"_id\",           # Field in reviews to match against\nname=\"full_reviews\"       # Name for the new array of joined reviews\n)\n# Execute to get listings with their full reviews\ndb[\"listings\"].aggregate(pipeline=pipeline.export())\n</code></pre> <p>See the combine collections guide for more details on joins.</p>"},{"location":"how-to/create-or-update-a-collection/#advanced-collection-operations","title":"Advanced Collection Operations","text":""},{"location":"how-to/create-or-update-a-collection/#using-out-vs-merge","title":"Using $out vs $merge","text":"<p>MongoDB provides two main stages for creating or updating collections:</p> <ul> <li>$out: Replaces an entire collection with the results of the pipeline. This is what we used above.</li> <li>$merge: Provides more granular control, allowing you to update, replace, or insert documents selectively.</li> </ul> <p>For partial updates or when you need to handle document conflicts, <code>$merge</code> is generally the better choice:</p> <pre><code># Example using $merge instead of $out (pseudocode)\npipeline.merge(\ninto=\"target_collection\",     # Target collection\non=\"_id\",                     # Field to match documents on\nwhenMatched=\"merge\",          # How to handle matches: merge, replace, keepExisting, etc.\nwhenNotMatched=\"insert\"       # What to do with new documents\n)\n</code></pre> <p>The <code>$merge</code> stage gives you fine-grained control over how documents are combined, making it ideal for incremental updates and data migrations.</p>"},{"location":"how-to/home/","title":"Home","text":"<p>The next pages, will show you some of the common use cases I faced and that led me to use the aggregation framework.</p>"},{"location":"how-to/home/#common-use-cases","title":"\ud83e\udde9 Common Use Cases","text":"<p>Below is a table of common MongoDB use cases and the corresponding guides in our documentation:</p> Use Case Description Reference Selecting Nested Documents Extract and work with embedded documents Nested Document Guide Combining Collections Join data from multiple collections Combine Collections Guide Creating/Updating Collections Manage collections programmatically Collection Management Guide"},{"location":"how-to/select-a-nested-document/","title":"Select a nested document","text":"<p>This guide shows how to extract and work with nested documents in MongoDB.</p>"},{"location":"how-to/select-a-nested-document/#when-to-use-this","title":"When to Use This","text":"<p>This approach is useful when working with collections that embed related documents instead of using separate collections. Common examples include:</p> <ul> <li>Comments embedded in blog posts</li> <li>Reviews embedded in product listings</li> <li>Address details embedded in user profiles</li> </ul>"},{"location":"how-to/select-a-nested-document/#example-finding-reviews-by-a-specific-reviewer","title":"Example: Finding Reviews by a Specific Reviewer","text":"<p>We'll use the <code>listingsAndReviews</code> collection from the <code>sample_airbnb</code> database, where reviews are embedded within listing documents.</p>"},{"location":"how-to/select-a-nested-document/#the-pipeline-approach","title":"The Pipeline Approach","text":"<p>To extract all reviews by a specific reviewer, we'll use three stages:</p> <ol> <li><code>$unwind</code>: Deconstruct the <code>reviews</code> array into individual documents</li> <li><code>$replaceRoot</code>: Promote each review to become the root document</li> <li><code>$match</code>: Filter for the specific reviewer</li> </ol> <pre><code># /!\\    /!\\    /!\\\n# Imports\n# and boilerplate code\n# to get the db object \n# are not included\n# /!\\    /!\\    /!\\\n# The reviewer_id whose reviews we want to retrieve\nreviewer_id = \"2961855\"\n# Building the pipeline\npipeline = Pipeline()\npipeline.unwind(\n\"reviews\"\n).replace_root(\n\"reviews\"\n).match(\nreviewer_id=reviewer_id\n)\n# Executing the pipeline\ncursor = db[\"listingsAndReviews\"].aggregate(pipeline=pipeline.export())\ndocuments = list(cursor)\n</code></pre>"},{"location":"how-to/select-a-nested-document/#sample-result","title":"Sample Result","text":"<p>The first document in our results:</p> <pre><code>{\n'_id': '197072826',\n'date': datetime.datetime(2017, 9, 24, 4, 0),\n'listing_id': '18776184',\n'reviewer_id': '2961855',\n'reviewer_name': 'Uge',\n'comments': 'Our stay at Alfredo\u2019s place was amazing. \\n\\nThe place is spacious, very clean, comfortable, decorated with good taste, and has everything one may need. I really liked his apartment. \\n\\nIt is very well located, the restaurants and bars around are great and in an easy 30 minute walk you are downtown or in old Montreal. Very pleasant area to be outside and felt very safe. \\n\\nAlfredo always answered my messages within 5 minutes and was incredibly helpful and generous. \\n\\nI highly recommend this place. Thank you Alfredo!'\n}\n</code></pre>"},{"location":"how-to/select-a-nested-document/#adapting-to-other-scenarios","title":"Adapting to Other Scenarios","text":""},{"location":"how-to/select-a-nested-document/#one-to-one-relationships","title":"One-to-One Relationships","text":"<p>For non-array nested fields like <code>address</code>, skip the <code>unwind</code> stage:</p> <pre><code># Extract address documents from listings\npipeline = Pipeline()\npipeline.replace_root(\n\"address\"\n).match(\ncountry=\"United States\"\n)\ncursor = db[\"listingsAndReviews\"].aggregate(pipeline=pipeline.export())\naddresses = list(cursor)\n</code></pre>"},{"location":"how-to/select-a-nested-document/#deep-nesting","title":"Deep Nesting","text":"<p>For deeply nested structures, chain multiple operations:</p> <pre><code># Access amenities.details.highlights (hypothetical nested structure)\npipeline = Pipeline()\npipeline.unwind(\n\"amenities\"\n).replace_root(\n\"amenities.details\"\n).unwind(\n\"highlights\"\n).replace_root(\n\"highlights\"\n).match(\nfeatured=True\n)\ncursor = db[\"listingsAndReviews\"].aggregate(pipeline=pipeline.export())\n</code></pre>"},{"location":"how-to/select-a-nested-document/#preserving-context","title":"Preserving Context","text":"<p>To keep information from the parent document:</p> <pre><code># Keep listing name while working with reviews\npipeline = Pipeline()\npipeline.project({\n\"listing_name\": 1, \n\"review\": \"$reviews\"\n}).unwind(\n\"review\"\n).match(\n\"review.reviewer_id\": \"2961855\"\n)\n# Result includes both the review and the listing name\ncursor = db[\"listingsAndReviews\"].aggregate(pipeline=pipeline.export())\n</code></pre>"},{"location":"how-to/setup/","title":"Get Data","text":"<p>This guide will show you how to setup an Atlas Cluster and download sample data to follow the tutorial and play with monggregate.</p>"},{"location":"how-to/setup/#instructions","title":"Instructions","text":"<p>1. The first step is to create an Atlas account (if you do not have one already). You can do it here. Simply fill the form and click on \"Create your Atlas account\".  Alternatively, you can sign up with Google.</p> <p>2. Once your account is created, you will to create a free tier cluster. Click on \"Build a Database\" and follow the steps. Select the M0 free cluster.  You can choose the cloud provider and the region that yout want. Name your cluster as pleased and click on \"Create Cluster\". </p> <p>3. Once your cluster is created, you will need to create a database user and whitelist your ip. You should be redirected to a security quickstart page guiding you to create a database user and adding your IP address to the IP access whitelist.</p> <p>4. Click on the three dots next to \"Browse Collections\" and then on \"Load Sample Dataset\". This might take a few minutes.</p> <p>5. You are now ready to follow the tutorial. You can find the first page here. You should now see the following databases when clicking on \"Browse Collections\".</p> <ul> <li><code>sample_airbnb</code></li> <li><code>sample_analytics</code></li> <li><code>sample_geospatial</code></li> <li><code>sample_guides</code></li> <li><code>sample_mflix</code></li> <li><code>sample_restaurants</code></li> <li><code>sample_supplies</code></li> <li><code>sample_training</code></li> <li><code>sample_weatherdata</code></li> </ul>"},{"location":"how-to/setup/#references","title":"References","text":"<ul> <li>This video shows the above steps.</li> <li>This guide briefly encompasses the above steps and goes a step further by showing you how to connect to your database in python with pymongo.</li> </ul>"},{"location":"how-to/commons/combine-collections/","title":"Combining Collections","text":"<p>This guide demonstrates how to merge data from two collections using MongoDB's aggregation framework.</p>"},{"location":"how-to/commons/combine-collections/#use-case","title":"Use Case","text":"<p>You need to combine related data from separate collections - in this case, retrieving listings along with their associated reviews.</p>"},{"location":"how-to/commons/combine-collections/#prerequisites","title":"Prerequisites","text":"<p>This guide uses the collections we created in the previous guide where we split the <code>listingsAndReviews</code> collection into separate <code>listings</code> and <code>reviews</code> collections.</p>"},{"location":"how-to/commons/combine-collections/#using-lookup","title":"Using $lookup","text":"<p>The <code>$lookup</code> operation performs a left outer join, allowing you to incorporate documents from one collection into matching documents from another.</p> <pre><code>from monggregate import Pipeline\n# Define the pipeline\npipeline = Pipeline()\npipeline.lookup(\nright=\"reviews\",         # Target collection we're joining with\nleft_on=\"_id\",           # Field in the listings collection\nright_on=\"listing_id\",   # Field in the reviews collection that matches\nname=\"reviews\"           # Output field to store the joined data\n)\n# Execute the pipeline on the listings collection\nresults = db[\"listings\"].aggregate(pipeline=pipeline.export())\n</code></pre>"},{"location":"how-to/commons/combine-collections/#result-structure","title":"Result Structure","text":"<p>After execution, each document from the <code>listings</code> collection will contain a new <code>reviews</code> array field with all matching review documents.</p>"},{"location":"how-to/commons/combine-collections/#additional-options","title":"Additional Options","text":"<p>For more control over joined data: - Use <code>pipeline.project()</code> after lookup to shape the output - Add matching conditions with <code>let</code> and <code>pipeline</code> parameters - Explore the <code>$unwind</code> stage to process array results</p>"},{"location":"how-to/commons/combine-collections/#related-topics","title":"Related Topics","text":"<ul> <li>Selecting Nested Documents</li> <li>MongoDB Aggregation Framework</li> </ul>"},{"location":"intro/mongodb-aggregation-framework/","title":"\ud83d\udd04 MongoDB Aggregation Framework","text":"<p>The MongoDB Aggregation Framework is an essential tool for any developer working with MongoDB. It offers advanced querying capabilities that are not available in MQL.</p>"},{"location":"intro/mongodb-aggregation-framework/#usage","title":"\ud83d\ude80 Usage","text":"<p>Even if the name focuses on the aggregation part of the framework, it can actually be used for the following purposes:</p>"},{"location":"intro/mongodb-aggregation-framework/#data-summarization-and-reporting","title":"\ud83d\udcca Data Summarization and Reporting","text":"<p>\ud83d\udca1 This is the actual aggregation in \"aggregation framework\".</p> <p>The aggregation framework allows you to categorize data, group documents, calculate aggregated values like totals, averages, counts, and more, with stages like <code>$group</code>, <code>$count</code>, <code>$bucket</code>, <code>$bucketAuto</code>, <code>$facet</code>, <code>$sortBycount</code>.</p>"},{"location":"intro/mongodb-aggregation-framework/#data-transformation-and-enrichment","title":"\ud83d\udd04 Data Transformation and Enrichment","text":"<p>\ud83d\udcd8 This is one of the lesser known use cases of the framework.</p> <p>It can be used to apply complex transformations to your data, and enrich existing documents with additional information. The main \"functions\" are <code>$addFields</code>, <code>$densify</code>, <code>$fill</code>, <code>$replaceWith</code>, <code>$merge</code>, <code>$out</code>.</p> <p>You can see examples of this in Create or update a collection.</p>"},{"location":"intro/mongodb-aggregation-framework/#join-like-operations","title":"\ud83d\udd17 Join-like Operations","text":"<p>Another important feature is the ability to perform join-like operations on your data.</p> <p>The frameworks exposes several functions to combine data from multiple collections. You can combine collections horizontally or vertically respectively with the <code>$lookup</code> and <code>$unionWith</code> stages.</p> <p>\ud83d\udd0d See Merge collections for some examples.</p>"},{"location":"intro/mongodb-aggregation-framework/#time-series-analysis","title":"\u23f1\ufe0f Time Series Analysis","text":"<p>The framework also defines several operators that can be used to enhance some of the stages mentioned above.</p> <p>Among those operators, a couple of them are specifically designed to work with time series data. You can use them to: - \ud83d\udcc5 Group documents by time intervals - \ud83e\uddee Perform calculations on those groups</p> <p>Such operators include <code>$dateAdd</code>, <code>$dateDiff</code>, <code>$millisecond</code>, <code>$toDate</code>, <code>$dateFromString</code>, <code>$dateFromParts</code> and much more.</p>"},{"location":"intro/mongodb-aggregation-framework/#geospatial-analysis","title":"\ud83c\udf0d Geospatial Analysis","text":"<p>Similarly, the framework has capabilities to perform geospatial analysis on your data. </p> <p>In particular, you can compute distances between points, and find documents within a certain distance of a given point with the <code>$geoNear</code> stage.</p>"},{"location":"intro/mongodb-aggregation-framework/#textual-search-and-analysis","title":"\ud83d\udd0d Textual Search and Analysis","text":"<p>Finally, one of the most interesting features of the framework (and also one of the less expected from the name) is textual search.</p> <p>\ud83d\udcda This part could be viewed as a framework on its own but, for some reason, was integrated to the aggregation framework.</p> <p>The aggregation framework leverages MongoDB Atlas full-text search capabilities. Textual search, unlike string matching, which looks for exact matches of a query term, involves finding documents that contain the query term or a related term.</p> <p>The entry points for this feature are the <code>$search</code> and <code>$searchMeta</code> stages. However, the reason I said this part could be viewed as a framework on its own previously is that <code>$search</code> and <code>$searchMeta</code> come with their own set operators. Such operators include <code>$autocomplete</code>, <code>$facet</code>, <code>$text</code>, <code>$compound</code> and much more.</p>"},{"location":"intro/mongodb-aggregation-framework/#concepts","title":"\ud83e\udde9 Concepts","text":"<p>The previous section makes references to several key concepts that are important to understand to use the aggregation framework. This section will introduce those concepts and explain them in more detail.</p>"},{"location":"intro/mongodb-aggregation-framework/#stage","title":"\ud83d\udd04 Stage","text":"<p>\ud83d\udca1 A stage is an operation on your data. It can be a querying operation, an aggregation, a transformation, a join, a textual search, a sorting operation, etc. You can view it as a function.</p> <p>Stages are the building blocks of an aggregation pipeline. Each stage represents a specific data processing operation that is applied to a set of documents. These stages are arranged in a sequence to achieve the desired transformation of the data.</p>"},{"location":"intro/mongodb-aggregation-framework/#pipeline","title":"\ud83d\udcda Pipeline","text":"<p>A pipeline is a set of stages that are executed in sequence. The output of a stage is the input of the next stage.  The output of the last stage is the output of the pipeline. The input of the first stage in a pipeline is the entire set of documents of the collection targeted by the pipeline.</p>"},{"location":"intro/mongodb-aggregation-framework/#operator","title":"\ud83d\udee0\ufe0f Operator","text":"<p>Operators are the tools used within each stage to perform specific operations on the data. They allow for a wide range of computations, transformations, and evaluations. Examples of operators include arithmetic operators, logical operators, array operators, and more.</p>"},{"location":"intro/mongodb-aggregation-framework/#expression","title":"\ud83d\udcdd Expression","text":"<p>\ud83d\udd0d Probably the most difficult concept to grasp is the concept of an expression. It is also the most important one.</p> <p>Expressions are a bit hard to define. They are actually not even properly defined in the official MongoDB documentation. Here how they are referred to in their documentation:</p> <p>Expressions can include field paths, literals, system variables, expression objects, and expression operators. Expressions can be nested.</p> <p>The reason why it is hard to define an expression is because the concepts of expression and operator are closely related (but still distinct).</p> <p>\u2139\ufe0f Note: In fact, operators produce expressions.</p> <p>An expression is a more general term that refers to a combination of values, variables, and operators that, when evaluated, results in a single value or object. An expression can include one or more operators to perform computations or transformations.</p>"},{"location":"intro/mongodb-umbrella/","title":"\ud83c\udf10 MongoDB Ecosystem Overview","text":"<p>MongoDB has evolved into one of the most comprehensive database management systems in the market. While it's primarily known as a document-oriented NoSQL database, it offers a rich ecosystem of features and services for modern data management.</p>"},{"location":"intro/mongodb-umbrella/#core-components","title":"\ud83d\udccb Core Components","text":""},{"location":"intro/mongodb-umbrella/#mql-mongodb-query-language","title":"MQL (MongoDB Query Language)","text":"<p>MQL is MongoDB's native Query Language, using a JSON-like syntax to interact with your data. It enables:</p> <ul> <li>\ud83d\udd04 CRUD Operations: Create, Read, Update, and Delete documents</li> <li>\ud83d\udee0\ufe0f Flexible Querying: Rich query capabilities with support for complex conditions</li> <li>\ud83d\udd0c Driver Integration: Works seamlessly with official and non-officialdrivers and ODMs</li> </ul> <p>\ud83d\udca1 Note: While MQL is powerful, this documentation focuses on the aggregation framework. For detailed MQL documentation, visit MongoDB's official documentation.</p>"},{"location":"intro/mongodb-umbrella/#aggregation-framework","title":"Aggregation Framework \ud83c\udfaf","text":"<p>The aggregation framework is MongoDB's answer to complex data processing and analytics. It allows you to:</p> <ul> <li>\ud83d\udd04 Transform and combine documents</li> <li>\ud83d\udcca Perform complex calculations</li> <li>\ud83d\udcc8 Generate analytics and reports</li> <li>\ud83d\udd0d Process data in multiple stages</li> </ul> <p>\ud83c\udfaf Why It Matters: The aggregation framework is what enables MongoDB to compete with traditional SQL databases for complex data operations.</p> <p>While MongoDB provides the framework, building aggregation pipelines can be complex. This is where <code>monggregate</code> comes in, offering an intuitive OOP interface to make pipeline construction easier.</p> <p>\ud83d\udcda Learn More: Dive deeper into the aggregation framework in the next section.</p>"},{"location":"intro/mongodb-umbrella/#atlas-search","title":"Atlas Search \ud83d\udd0d","text":"<p>Atlas Search is MongoDB's integrated full-text search solution, powered by Apache Lucene. It's particularly relevant because:</p> <ul> <li>\ud83d\udd17 Integration: Seamlessly integrates with the aggregation framework</li> <li>\ud83d\udd0d Keyword Search: Provides powerful text search capabilities</li> <li>\ud83e\uddee Vector Search: AI-powered semantic search enabling similarity matching, natural language processing, and embedding-based queries for next-generation applications</li> </ul> <p>\ud83d\udcd6 Learn More: Check out the search tutorial for details on using Atlas Search with <code>monggregate</code>.</p>"},{"location":"intro/mongodb-umbrella/#additional-mongodb-capabilities","title":"\ud83c\udf1f Additional MongoDB Capabilities","text":"<p>MongoDB continues to evolve with features like:</p> <ul> <li>\ud83d\udcc8 Time Series Collections: Optimized for time-series data</li> <li>\ud83d\udd04 Change Streams: Real-time data change notifications</li> <li>\ud83d\udd12 Encryption: At-rest, in-transit anre more importantly in-use queryable encryption.</li> </ul> <p>\u2139\ufe0f Note: While these features are powerful, they're currently outside the scope of <code>monggregate</code>. <code>monggregate</code> focuses on making the aggregation framework more accessible and developer-friendly.</p>"},{"location":"intro/why-use-monggregate/","title":"\ud83d\udcca Why Use Monggregate?","text":"<p>In this page, we'll explore the key benefits and use cases for <code>monggregate</code> - a tool designed to simplify your work with MongoDB's aggregation framework.</p>"},{"location":"intro/why-use-monggregate/#what-is-monggregate","title":"\ud83d\udd0d What is Monggregate?","text":"<p>Let's start by clarifying what <code>monggregate</code> is:</p> <p>\ud83d\udca1 <code>monggregate</code> is a specialized query builder for MongoDB's aggregation framework.</p> <p>It is not a MongoDB driver or an Object Document Mapper (ODM), but rather a complementary tool that works alongside them.</p> <p>If you're not familiar with query builders, they bridge the gap between raw queries and full ORMs:</p> <ul> <li>Raw queries: Direct, verbose, and often difficult to maintain</li> <li>Query builders: Programmatic interfaces that help construct queries</li> <li>ORMs/ODMs: Full object-to-database mapping layers</li> </ul> <p>\ud83d\udcfa For a deeper understanding, check out this video from Arjan Codes explaining query builders (with SQL examples that apply conceptually to NoSQL as well).</p>"},{"location":"intro/why-use-monggregate/#why-use-monggregate_1","title":"\u2728 Why Use Monggregate?","text":"<p>As detailed in the previous page, MongoDB's aggregation framework is powerful for data analytics and transformations. However, working with it presents several challenges:</p>"},{"location":"intro/why-use-monggregate/#common-pain-points","title":"\ud83d\udeab Common Pain Points","text":"<ul> <li>\ud83d\udcc8 Steep learning curve - The aggregation framework requires understanding a complex syntax</li> <li>\ud83d\udcdd Excessive verbosity - Pipelines quickly become large and difficult to read</li> <li>\ud83d\udd27 Limited Python integration - No native Pythonic API exists in the standard tools</li> <li>\ud83d\udcda Documentation gaps - Insufficient documentation in pymongo</li> </ul>"},{"location":"intro/why-use-monggregate/#how-monggregate-solves-these-problems","title":"\ud83c\udfaf How Monggregate Solves These Problems","text":"<p><code>monggregate</code> addresses these challenges by:</p> <ul> <li>Providing a clean Python API for the aggregation framework</li> <li>Improving readability and maintainability of pipeline code</li> <li>Reducing verbosity while maintaining full functionality</li> <li>Embedding MongoDB documentation directly in your code</li> </ul> <p>\ud83d\udca1 Example: Instead of writing complex JSON-like dictionaries, you can use intuitive Python methods and classes.</p>"},{"location":"intro/why-use-monggregate/#developer-experience-benefits","title":"\ud83d\udcbb Developer Experience Benefits","text":"<p>With <code>monggregate</code>, you gain:</p> <ul> <li>IDE integration with autocompletion for stages, operators, parameters</li> <li>Type hints showing available options and their descriptions</li> <li>Inline documentation eliminating constant reference to external docs</li> <li>Pipeline testing directly in your application or notebooks</li> </ul>"},{"location":"intro/why-use-monggregate/#who-should-use-it","title":"\ud83d\udc65 Who Should Use It?","text":""},{"location":"intro/why-use-monggregate/#newcomers-to-mongodb","title":"\ud83c\udd95 Newcomers to MongoDB","text":"<p>If you're new to MongoDB or the aggregation framework, <code>monggregate</code> offers: * A gentler learning curve * Clear guidance on available options * Fewer syntax errors while learning</p>"},{"location":"intro/why-use-monggregate/#experienced-mongodb-developers","title":"\ud83e\uddea Experienced MongoDB Developers","text":"<p>Even if you're already familiar with MongoDB, <code>monggregate</code> provides: * Faster pipeline development * Reduced errors in complex queries * Better readability for team collaboration * Simplified maintenance of complex pipelines</p>"},{"location":"intro/why-use-monggregate/#how-to-use-it","title":"\ud83d\ude80 How to Use It?","text":"<p>Ready to get started with <code>monggregate</code>? The following pages will guide you through:</p> <ul> <li>Installation and setup</li> <li>Building your first pipeline</li> <li>Advanced techniques for complex scenarios</li> <li>Best practices for production use</li> </ul> <p>\ud83d\udcd8 Next Step: Continue to our Getting Started guide to begin working with <code>monggregate</code>.</p>"},{"location":"reference/dollar/","title":"\ud83d\udcb2 Dollar and DollarDollar Reference","text":"<p>In MongoDB's aggregation framework, dollar signs (<code>$</code> and <code>$$</code>) have special meaning. Monggregate abstracts these with two powerful classes: <code>Dollar</code> and <code>DollarDollar</code>.</p>"},{"location":"reference/dollar/#dollar-class-s","title":"\ud83d\udcb2 Dollar Class (<code>S</code>)","text":"<p>The <code>Dollar</code> class is a singleton that provides an interface to MongoDB's operators and field references. It is instantiated and exported as <code>S</code>.</p>"},{"location":"reference/dollar/#purpose","title":"\ud83c\udfaf Purpose","text":"<ol> <li>Operator Access: Provides a Python interface to all MongoDB operators with proper typing and validation</li> <li>Field References: Creates references to document fields using MongoDB's dollar prefix notation</li> </ol>"},{"location":"reference/dollar/#usage","title":"\ud83d\udee0\ufe0f Usage","text":"<p>Import the <code>S</code> object:</p> <pre><code>from monggregate import S\n</code></pre>"},{"location":"reference/dollar/#creating-operators","title":"Creating Operators","text":"<pre><code># Arithmetic operators\naddition = S.add(\"$price\", \"$tax\")  # Returns {\"$add\": [\"$price\", \"$tax\"]}\nmultiply = S.multiply(\"$quantity\", \"$price\")  # Returns {\"$multiply\": [\"$quantity\", \"$price\"]}\n# Comparison operators\ngreater_than = S.gt(\"$age\", 18)  # Returns {\"$gt\": [\"$age\", 18]}\nequals = S.eq(\"$status\", \"active\")  # Returns {\"$eq\": [\"$status\", \"active\"]}\n# Boolean operators\nlogic_and = S.and_([S.gt(\"$age\", 18), S.lt(\"$age\", 65)])\n# Array operators\narray_size = S.size(\"$tags\")  # Returns {\"$size\": \"$tags\"}\n</code></pre>"},{"location":"reference/dollar/#field-references","title":"Field References","text":"<pre><code># Reference a field directly\nname_field = S.name  # Returns \"$name\"\n# Explicit field reference\nprice_field = S.field(\"price\")  # Returns \"$price\"\n</code></pre>"},{"location":"reference/dollar/#methods-vs-attributes","title":"\ud83d\udd04 Methods vs. Attributes","text":"<p>The <code>Dollar</code> class distinguishes between methods and attributes:</p> <ul> <li>Methods like <code>S.sum()</code>, <code>S.avg()</code>, <code>S.gt()</code> create operators</li> <li>Attributes like <code>S.name</code>, <code>S.price</code>, <code>S.customer_id</code> create field references</li> </ul>"},{"location":"reference/dollar/#available-operator-categories","title":"\ud83d\uddc2\ufe0f Available Operator Categories","text":"<p>The <code>S</code> object provides access to these operator categories:</p> <ul> <li>Accumulators: <code>S.sum()</code>, <code>S.avg()</code>, <code>S.push()</code>, etc.</li> <li>Arithmetic: <code>S.add()</code>, <code>S.multiply()</code>, <code>S.divide()</code>, etc.</li> <li>Array: <code>S.size()</code>, <code>S.filter()</code>, <code>S.in_()</code>, etc.</li> <li>Boolean: <code>S.and_()</code>, <code>S.or_()</code>, <code>S.not_()</code>, etc.</li> <li>Comparison: <code>S.eq()</code>, <code>S.gt()</code>, <code>S.lt()</code>, etc.</li> <li>Conditional: <code>S.cond()</code>, <code>S.if_null()</code>, <code>S.switch()</code>, etc.</li> <li>Date: <code>S.millisecond()</code>, etc.</li> <li>Objects: <code>S.merge_objects()</code>, <code>S.object_to_array()</code>, etc.</li> <li>String: <code>S.concat()</code>, <code>S.date_to_string()</code>, etc.</li> <li>Type: <code>S.type_()</code></li> </ul> <p>\ud83d\udcdd Note: Some method names differ slightly from their MongoDB counterparts to avoid Python reserved keywords. For example, <code>S.and_()</code> instead of <code>and</code> (which is a Python keyword).</p>"},{"location":"reference/dollar/#dollardollar-class-ss","title":"\ud83d\udcb2\ud83d\udcb2 DollarDollar Class (<code>SS</code>)","text":"<p>The <code>DollarDollar</code> class is a singleton that provides access to MongoDB's aggregation variables (using <code>$$</code> prefix). It is instantiated and exported as <code>SS</code>.</p>"},{"location":"reference/dollar/#purpose_1","title":"\ud83c\udfaf Purpose","text":"<p>Provides access to: - System aggregation variables (<code>$$ROOT</code>, <code>$$CURRENT</code>, etc.) - User-defined variables in aggregation expressions</p>"},{"location":"reference/dollar/#usage_1","title":"\ud83d\udee0\ufe0f Usage","text":"<p>Import the <code>SS</code> object:</p> <pre><code>from monggregate import SS\n</code></pre>"},{"location":"reference/dollar/#system-variables","title":"System Variables","text":"<pre><code># Access system variables (constants)\nroot = SS.ROOT       # Returns \"$$ROOT\"\ncurrent = SS.CURRENT # Returns \"$$CURRENT\"\nnow = SS.NOW         # Returns \"$$NOW\"\n</code></pre>"},{"location":"reference/dollar/#user-defined-variables","title":"User-defined Variables","text":"<pre><code># Reference user-defined variables\nproduct = SS.product_name  # Returns \"$$product_name\"\ncustomer = SS.customer_id  # Returns \"$$customer_id\"\n</code></pre>"},{"location":"reference/dollar/#available-system-variables","title":"\ud83d\uddc2\ufe0f Available System Variables","text":"<p>The <code>SS</code> object provides these built-in system variables:</p> <ul> <li><code>SS.CLUSTER_TIME</code> - Current timestamp across the deployment</li> <li><code>SS.NOW</code> - Current datetime value</li> <li><code>SS.ROOT</code> - The root document </li> <li><code>SS.CURRENT</code> - Reference to start of the field path</li> <li><code>SS.REMOVE</code> - Conditional field exclusion</li> <li><code>SS.DESCEND</code>, <code>SS.PRUNE</code>, <code>SS.KEEP</code> - $redact expression results</li> </ul>"},{"location":"reference/dollar/#real-world-example","title":"\ud83c\udf1f Real-world Example","text":"<p>This example demonstrates combining <code>S</code> and <code>SS</code> in a pipeline:</p> <pre><code>from monggregate import Pipeline, S, SS\npipeline = Pipeline()\n# Define the pipeline\npipeline.lookup(\nright=\"orders\",\nleft_on=\"_id\",\nright_on=\"customer_id\",\nname=\"customer_orders\"\n).add_fields(\n# Count total orders\norder_count=S.size(\"$customer_orders\"),\n# Calculate total spent using system variables\ntotal_spent=S.sum(\nS.multiply(\n\"$customer_orders.amount\", \nS.cond(\nS.eq(\"$customer_orders.status\", \"completed\"),\n1,\n0\n)\n)\n),\n# Find most expensive order\nmost_expensive_order=S.max_n(\n\"$customer_orders.amount\", \n1\n)\n).match(\n# Filter by expression using system variable\nS.gt(S.divide(\"$total_spent\", SS.NOW), 0.5)\n)\n</code></pre>"},{"location":"reference/dollar/#comparison-with-pipeline-class","title":"\ud83d\udd04 Comparison with Pipeline Class","text":"<p>The relationship between different Monggregate abstractions:</p> Class Singleton MongoDB Element Purpose <code>Pipeline</code> N/A Aggregation Pipeline Defines sequence of operations <code>Stage</code> classes N/A Aggregation Stages Individual pipeline steps <code>Dollar</code> <code>S</code> $ Operators &amp; References Expressions and field references <code>DollarDollar</code> <code>SS</code> $$ Variables System and user variables <p>\ud83d\udca1 Just as <code>Pipeline</code> provides methods for all stages, the <code>S</code> object provides methods for all MongoDB operators. They serve similar roles in different contexts - <code>Pipeline</code> for constructing aggregation sequences, and <code>S</code> for building expressions with operators. </p>"},{"location":"tutorial/getting-started/","title":"\ud83d\ude80 Getting Started with Monggregate","text":""},{"location":"tutorial/getting-started/#overview","title":"\ud83d\udccb Overview","text":"<p>Monggregate is a Python library designed to simplify working with MongoDB aggregation pipelines. It provides an object-oriented interface that lets you focus on data transformation requirements rather than MongoDB syntax.</p>"},{"location":"tutorial/getting-started/#installation","title":"\ud83d\udce5 Installation","text":"<p>Monggregate is available on PyPI:</p> <pre><code>pip install monggregate\n</code></pre>"},{"location":"tutorial/getting-started/#requirements","title":"\u2705 Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>Dependencies: <code>pydantic</code>, <code>pyhumps</code>, and <code>typing-extensions</code></li> <li>A MongoDB driver for executing the query builder (e.g., <code>pymongo</code>)</li> </ul> <p>\ud83d\udcda For a complete list of requirements, see the requirements files in the repository.</p>"},{"location":"tutorial/getting-started/#basic-concepts","title":"\ud83e\udde9 Basic Concepts","text":"<p>Monggregate's primary components:</p> <ul> <li>\ud83d\udcda Pipeline: The main class used to build and chain MongoDB aggregation operations</li> <li>\ud83d\udd04 Stages: Individual operations like <code>match</code>, <code>group</code>, <code>sort</code>, etc.</li> <li>\ud83d\udee0\ufe0f Operators: MongoDB operators implemented with intuitive Python syntax</li> </ul>"},{"location":"tutorial/getting-started/#quick-start-example","title":"\u26a1 Quick Start Example","text":"<p>Here's a simple example to get you started:</p> <pre><code>import pymongo\nfrom monggregate import Pipeline\n# Connect to MongoDB\nclient = pymongo.MongoClient(\"&lt;insert-your-connection-string&gt;\")\ndb = client[\"sample_database\"]\n# Create a pipeline\npipeline = Pipeline()\n# Build your pipeline with chained operations\npipeline.match(\ncategory=\"electronics\"\n).sort(\nby=\"price\", \ndescending=True\n).limit(5)\n# Execute the pipeline\nresults = list(db[\"products\"].aggregate(pipeline.export()))\nprint(results)\n</code></pre>"},{"location":"tutorial/getting-started/#using-the-pipeline-builder","title":"\ud83d\udd27 Using the Pipeline Builder","text":"<p>\ud83d\udca1 The recommended way to use Monggregate is through the <code>Pipeline</code> class.</p> <pre><code>from monggregate import Pipeline\n# Initialize an empty pipeline\npipeline = Pipeline()\n# Build your pipeline with autocomplete assistance\npipeline.match(...)\n.group(...)\n.sort(...)\n</code></pre> <p>When you type <code>pipeline.</code> in your IDE, you'll see all available aggregation stages through autocompletion:</p> <p></p>"},{"location":"tutorial/getting-started/#advanced-usage","title":"\ud83c\udf1f Advanced Usage","text":"<p>Monggregate supports advanced MongoDB features like expressions and operators:</p> <pre><code>from monggregate import Pipeline, S\npipeline = Pipeline()\npipeline.match(\nyear=S.type_(\"number\")  # Using operators\n).group(\nby=\"year\",\nquery={\n\"count\": S.sum(1),\n\"titles\": S.push(\"$title\")\n}\n)\n</code></pre>"},{"location":"tutorial/getting-started/#next-steps","title":"\ud83d\udd1c Next Steps","text":"<ul> <li>\ud83d\udcda Learn more about building pipelines</li> <li>\ud83d\udd04 Explore available aggregation stages</li> <li>\ud83d\udee0\ufe0f Discover how to use MongoDB operators</li> <li>\ud83d\udd0d Try vector search capabilities</li> </ul>"},{"location":"tutorial/operators/","title":"\ud83d\udee0\ufe0f MongoDB Operators in Monggregate","text":"<p>MongoDB operators are the building blocks of aggregation stages, providing powerful data transformation capabilities. Monggregate makes these operators accessible through an intuitive Python interface.</p>"},{"location":"tutorial/operators/#understanding-operators","title":"\ud83e\udde0 Understanding Operators","text":""},{"location":"tutorial/operators/#relationship-with-stages","title":"\ud83d\udd04 Relationship with Stages","text":"<p>\ud83d\udca1 Operators and stages work together in a MongoDB aggregation pipeline.</p> <ul> <li>Optional but powerful: Some stages (like <code>Match</code>) can function without operators, while others (like <code>Group</code>) require operators to be useful</li> <li>Parallel usage: Unlike stages which are executed sequentially, multiple operators can be used simultaneously within a single stage</li> <li>Different syntax: Operators in aggregation pipelines often have different syntax than their MongoDB Query Language (MQL) counterparts</li> </ul>"},{"location":"tutorial/operators/#example-operators-in-action","title":"\ud83d\udcca Example: Operators in Action","text":"<p>Consider this simple example that counts and collects movie titles by year:</p> <pre><code>from monggregate import Pipeline, S\npipeline = Pipeline()\npipeline.group(\nby=\"year\",\nquery={\n\"movie_count\": S.sum(1),        # Count movies per year\n\"movie_titles\": S.push(\"$title\") # Collect all titles for each year\n}\n)\n</code></pre>"},{"location":"tutorial/operators/#using-operators-in-monggregate","title":"\ud83d\ude80 Using Operators in Monggregate","text":"<p>Monggregate provides two ways to access operators:</p> <ol> <li> <p>Direct import:    <pre><code>from monggregate.operators import Sum, Push\nsum_operator = Sum(1)\npush_operator = Push(\"$title\")\n</code></pre></p> </li> <li> <p>Using the <code>S</code> shortcut (recommended):    <pre><code>from monggregate import S\nsum_operator = S.sum(1)\npush_operator = S.push(\"$title\")\n</code></pre></p> </li> </ol> <p>\ud83d\udd0d The <code>S</code> shortcut is particularly convenient as it provides access to all operators through a single import.</p>"},{"location":"tutorial/operators/#the-s-and-ss-objects","title":"\ud83d\udd2e The <code>S</code> and <code>SS</code> Objects","text":"<p>Monggregate provides two special singleton objects that abstract MongoDB's dollar sign syntax:</p>"},{"location":"tutorial/operators/#the-s-object-dollar","title":"\ud83d\udcb2 The <code>S</code> Object (Dollar)","text":"<p>\ud83d\udd11 Key Concept: The <code>S</code> singleton directly mirrors MongoDB's <code>$</code> symbol and its dual role in the MongoDB query language.</p> <p>In MongoDB, the dollar sign (<code>$</code>) has two distinct meanings: 1. As a prefix for operators: <code>{ $sum: 1 }</code>, <code>{ $gt: 10 }</code> 2. As a prefix for field references: <code>\"$name\"</code>, <code>\"$address.city\"</code></p> <p>The <code>S</code> object faithfully reproduces this dual functionality in Python:</p> <ol> <li> <p>Operator Access: Methods on <code>S</code> create MongoDB operators:    <pre><code>from monggregate import S\n# Create operators\nsum_op = S.sum(1)                # Becomes {\"$sum\": 1}\ngt_op = S.gt(\"$price\", 100)      # Becomes {\"$gt\": [\"$price\", 100]}\n</code></pre></p> </li> <li> <p>Field References: Attributes of <code>S</code> create field references:    <pre><code># These are equivalent ways to reference the \"name\" field\nfield_ref1 = S.name       # Becomes \"$name\"\nfield_ref2 = S.field(\"name\")  # Also becomes \"$name\"\n</code></pre></p> </li> </ol> <p>\ud83d\udca1 This direct mapping to MongoDB's <code>$</code> symbol makes the transition between MongoDB query language and Monggregate's Python interface intuitive and straightforward.</p>"},{"location":"tutorial/operators/#why-use-s-instead-of-direct-syntax","title":"\ud83d\udcaa Why Use <code>S</code> Instead of Direct <code>$</code> Syntax?","text":"<p>While you could write MongoDB queries with direct string literals containing <code>$</code> signs, using the <code>S</code> object offers significant advantages:</p> <ol> <li> <p>Type Safety and Validation:    <pre><code># With S object - type checked, validated\nS.gt(\"$age\", 18)\n# Direct syntax - no validation, easy to make typos\n{\"$gt\": [\"$age\", 18]}  # Could easily mistype as \"$gte\" or \"$gtt\"\n</code></pre></p> </li> <li> <p>Code Completion and Documentation:</p> </li> <li>IDEs can provide autocompletion for <code>S.sum()</code>, <code>S.gt()</code>, etc.</li> <li>Documentation is accessible via docstrings and tooltips</li> <li> <p>No need to remember exact MongoDB syntax or consult external documentation</p> </li> <li> <p>Python-Native Interface:</p> </li> <li>Use Python conventions like snake_case methods (<code>S.object_to_array()</code> vs <code>\"$objectToArray\"</code>)</li> <li> <p>Operators like <code>$and</code>, <code>$in</code> that conflict with Python keywords are available as <code>S.and_()</code>, <code>S.in_()</code></p> </li> <li> <p>Consistent Syntax for Different Contexts:</p> </li> <li>MongoDB has different syntaxes for the same operator depending on context (query vs aggregation)</li> <li> <p><code>S</code> provides a unified interface regardless of where the operator is used</p> </li> <li> <p>Composability and Expressiveness:    <pre><code># Complex expressions are more readable with S\nS.and_([\nS.gt(\"$age\", 18),\nS.lt(\"$age\", 65),\nS.in_(\"$status\", [\"active\", \"pending\"])\n])\n# Versus direct syntax\n{\"$and\": [\n{\"$gt\": [\"$age\", 18]},\n{\"$lt\": [\"$age\", 65]},\n{\"$in\": [\"$status\", [\"active\", \"pending\"]]}\n]}\n</code></pre></p> </li> <li> <p>Reduced Syntax Errors:</p> </li> <li>Proper nesting of operators is handled automatically</li> <li>Correct placement of dollar signs is guaranteed</li> <li>Parameter count and types are validated</li> </ol> <p>\ud83d\ude80 The <code>S</code> object transforms MongoDB's JSON-based query language into a first-class Python experience, with all the tooling, safety, and convenience that brings.</p>"},{"location":"tutorial/operators/#the-ss-object-dollardollar","title":"\ud83d\udcb2\ud83d\udcb2 The <code>SS</code> Object (DollarDollar)","text":"<p>The <code>SS</code> object is an instance of the <code>DollarDollar</code> class that provides access to MongoDB's aggregation variables (prefixed with <code>$$</code>):</p> <pre><code>from monggregate import SS\n# Access system variables\nroot_var = SS.ROOT        # Returns \"$$ROOT\"\ncurrent_var = SS.CURRENT  # Returns \"$$CURRENT\"\n# Create references to user-defined variables\nproduct_var = SS.product_name  # Returns \"$$product_name\"\n</code></pre> <p>\ud83d\udcd8 System variables are uppercase constants on the <code>SS</code> object, while custom variables can be accessed via any attribute name.</p>"},{"location":"tutorial/operators/#combining-s-and-ss-in-expressions","title":"\ud83d\udd04 Combining <code>S</code> and <code>SS</code> in Expressions","text":"<p>The real power comes when combining these objects in expressions:</p> <pre><code>from monggregate import Pipeline, S, SS\npipeline = Pipeline()\npipeline.match(\nS.expr(S.eq(S.type(SS.ROOT), \"array\"))  # Match if the root document is an array\n).project(\nitems=1,\nfirst_item=S.arrayElemAt(SS.ROOT, 0)  # Get the first element of the root\n)\n</code></pre>"},{"location":"tutorial/operators/#operator-compatibility","title":"\ud83d\udd17 Operator Compatibility","text":"<p>Each operator is designed to work with specific stages. Monggregate's documentation includes compatibility information for each operator.</p> <p>For example, the <code>$mergeObjects</code> operator can only be used in these stages: - <code>$bucket</code> - <code>$bucketAuto</code> - <code>$group</code> - <code>$replaceRoot</code></p>"},{"location":"tutorial/operators/#advanced-example-multiple-operators","title":"\ud83c\udf1f Advanced Example: Multiple Operators","text":"<p>This example demonstrates using multiple operators together to analyze movie data:</p> <pre><code>from monggregate import Pipeline, S\n# Creating the pipeline\npipeline = Pipeline()\n# Using multiple operators together\npipeline.match(\nyear=S.type_(\"number\")  # Filter for documents where year is a number\n).group(\nby=\"year\",\nquery={\n\"movie_count\": S.sum(1),                # Count movies per year\n\"avg_runtime\": S.avg(\"$runtime\"),       # Calculate average runtime\n\"movie_titles\": S.push(\"$title\"),       # Collect all titles\n\"genres\": S.addToSet(\"$genres\")         # Collect unique genres\n}\n).match(\nmovie_count=S.gt(10)                        # Filter for years with &gt;10 movies\n).sort(\nby=\"movie_count\", \ndescending=True\n)\n</code></pre>"},{"location":"tutorial/operators/#complex-example-using-expressions","title":"\ud83e\udde9 Complex Example: Using Expressions","text":"<p>\ud83d\udcd8 Operators can be combined to create complex expressions.</p> <pre><code>from monggregate import Pipeline, S\n# Define a complex expression\ncomments_count = S.size(\"$comments\")\nhas_many_comments = S.gt(comments_count, 5)\nis_recent = S.gt(\"$year\", 2000)\n# Create pipeline using the expression\npipeline = Pipeline()\npipeline.lookup(\nright=\"comments\",\nright_on=\"movie_id\",\nleft_on=\"_id\",\nname=\"comments\"\n).add_fields(\ncomments_count=comments_count,\nis_popular=S.and_([has_many_comments, is_recent])\n).match(\nis_popular=True\n)\n</code></pre>"},{"location":"tutorial/operators/#available-operators","title":"\ud83d\udccb Available Operators","text":"<p>Monggregate supports all major MongoDB operators, organized by category:</p>"},{"location":"tutorial/operators/#accumulators","title":"\ud83d\udcca Accumulators","text":"<ul> <li><code>$avg</code> - Calculate average value</li> <li><code>$count</code> - Count documents</li> <li><code>$first</code> - Return first value in a group</li> <li><code>$last</code> - Return last value in a group</li> <li><code>$max</code> - Return maximum value</li> <li><code>$min</code> - Return minimum value</li> <li><code>$push</code> - Append values to an array</li> <li><code>$sum</code> - Calculate sum</li> </ul>"},{"location":"tutorial/operators/#arithmetic","title":"\ud83e\uddee Arithmetic","text":"<ul> <li><code>$add</code> - Addition</li> <li><code>$divide</code> - Division</li> <li><code>$multiply</code> - Multiplication</li> <li><code>$pow</code> - Exponentiation</li> <li><code>$subtract</code> - Subtraction</li> </ul>"},{"location":"tutorial/operators/#array","title":"\ud83d\udcdd Array","text":"<ul> <li><code>$arrayToObject</code> - Convert array to object</li> <li><code>$filter</code> - Filter array elements</li> <li><code>$first</code> - Return first array element</li> <li><code>$in</code> - Check if value exists in array</li> <li><code>$isArray</code> - Check if value is an array</li> <li><code>$last</code> - Return last array element</li> <li><code>$max_n</code> - Return n maximum values</li> <li><code>$min_n</code> - Return n minimum values</li> <li><code>$size</code> - Get array length</li> <li><code>$sortArray</code> - Sort array elements</li> </ul>"},{"location":"tutorial/operators/#boolean","title":"\u2696\ufe0f Boolean","text":"<ul> <li><code>$and</code> - Logical AND</li> <li><code>$not</code> - Logical NOT</li> <li><code>$or</code> - Logical OR</li> </ul>"},{"location":"tutorial/operators/#comparison","title":"\ud83d\udd0d Comparison","text":"<ul> <li><code>$cmp</code> - Compare values</li> <li><code>$eq</code> - Equal to</li> <li><code>$gt</code> - Greater than</li> <li><code>$gte</code> - Greater than or equal to</li> <li><code>$lt</code> - Less than</li> <li><code>$lte</code> - Less than or equal to</li> <li><code>$ne</code> - Not equal to</li> </ul>"},{"location":"tutorial/operators/#conditional","title":"\ud83d\udd00 Conditional","text":"<ul> <li><code>$cond</code> - Conditional expression</li> <li><code>$ifNull</code> - Replace null values</li> <li><code>$switch</code> - Switch statement</li> </ul>"},{"location":"tutorial/operators/#date","title":"\ud83d\udcc5 Date","text":"<ul> <li><code>$millisecond</code> - Extract milliseconds</li> <li><code>$dateFromString</code> - Convert string to date</li> <li><code>$dateToString</code> - Convert date to string</li> </ul>"},{"location":"tutorial/operators/#object","title":"\ud83e\uddf1 Object","text":"<ul> <li><code>$mergeObjects</code> - Combine multiple documents</li> <li><code>$objectToArray</code> - Convert object to array</li> </ul>"},{"location":"tutorial/operators/#string","title":"\ud83d\udcdd String","text":"<ul> <li><code>$concat</code> - Concatenate strings</li> <li><code>$dateFromString</code> - Parse date from string</li> <li><code>$dateToString</code> - Format date as string</li> </ul>"},{"location":"tutorial/operators/#search","title":"\ud83d\udd0d Search","text":"<p>\ud83d\udcda For search-specific operators, see the Search documentation.</p>"},{"location":"tutorial/operators/#mql-vs-aggregation-pipeline-syntax","title":"\ud83d\udd04 MQL vs. Aggregation Pipeline Syntax","text":"<p>\u2139\ufe0f Some operators have different syntax in MQL queries versus aggregation pipelines.</p>"},{"location":"tutorial/operators/#example-greater-than-or-equal-gte","title":"Example: Greater Than or Equal (<code>$gte</code>)","text":"<p>In an MQL query: <pre><code>{\n\"year\": {\"$gte\": 2010}  # Find documents where year &gt;= 2010\n}\n</code></pre></p> <p>In an aggregation pipeline: <pre><code>{\n\"$gte\": [\"$year\", 2010]  # Compare if year field value &gt;= 2010\n}\n</code></pre></p> <p>With Monggregate, the syntax is unified and simplified: <pre><code>from monggregate import S\n# In a match stage\npipeline.match(year=S.gte(2010))\n# In an expression\nis_recent = S.gte(\"$year\", 2010)\n</code></pre></p> <p>This consistent interface helps developers avoid the complexity of different syntaxes for the same logical operations.</p>"},{"location":"tutorial/pipeline/","title":"\ud83d\udd04 MongoDB Aggregation Pipelines","text":"<p>Pipelines are a fundamental concept in MongoDB's aggregation framework, providing a powerful way to process and transform data. The <code>Pipeline</code> class in Monggregate is designed to make building and executing these pipelines intuitive and efficient.</p>"},{"location":"tutorial/pipeline/#building-a-pipeline","title":"\ud83c\udfd7\ufe0f Building a Pipeline","text":"<p>\ud83d\udca1 The <code>Pipeline</code> class is the core of Monggregate, offering methods that correspond to each MongoDB aggregation stage.</p> <p>Every stage in MongoDB's aggregation framework has an equivalent class and method in Monggregate.</p>"},{"location":"tutorial/pipeline/#basic-pipeline-construction","title":"\ud83d\udd30 Basic Pipeline Construction","text":"<p>Creating a pipeline is straightforward:</p> Basic Pipeline<pre><code>from monggregate import Pipeline\n# Initialize an empty pipeline\npipeline = Pipeline()\n# Add a Match stage to filter documents\npipeline.match(title=\"A Star Is Born\")\n</code></pre> <p>Each method returns the pipeline instance, enabling method chaining to build complex pipelines with a clean, readable syntax:</p> Method Chaining<pre><code>from monggregate import Pipeline\n# Build a multi-stage pipeline\npipeline = Pipeline()\npipeline.match(\ntitle=\"A Star Is Born\"\n).sort(\nby=\"year\",\ndescending=True\n).limit(\nvalue=1\n)\n</code></pre> <p>\ud83d\udcd8 This pipeline will filter for movies titled \"A Star Is Born\", sort them by year in descending order, and return only the first result (the most recent movie with that title).</p>"},{"location":"tutorial/pipeline/#executing-a-pipeline","title":"\u26a1 Executing a Pipeline","text":"<p>Monggregate provides a simple way to export your pipeline to a format compatible with your MongoDB driver or ODM of choice:</p> Executing a Pipeline<pre><code>import pymongo\nfrom monggregate import Pipeline\n# Connect to MongoDB\nMONGODB_URI = \"&lt;insert-your-connection-string&gt;\"\nclient = pymongo.MongoClient(MONGODB_URI)\ndb = client[\"sample_mflix\"]\n# Create and build your pipeline\npipeline = Pipeline()\npipeline.match(\ntitle=\"A Star Is Born\"\n).sort(\nby=\"year\"\n).limit(\nvalue=1\n)\n# Execute the pipeline\ncursor = db[\"movies\"].aggregate(pipeline.export())\nresults = list(cursor)\nprint(results)\n</code></pre> <p>\ud83d\udd0d The <code>export()</code> method converts your Monggregate pipeline into the standard MongoDB format (a list of stage dictionaries) that any MongoDB driver can execute.</p>"},{"location":"tutorial/pipeline/#alternative-using-stage-classes-directly","title":"\ud83d\udd04 Alternative: Using Stage Classes Directly","text":"<p>For more complex scenarios or when you need to reuse stages, you can work directly with stage classes:</p> Working with Stage Classes<pre><code>import pymongo\nfrom monggregate import Pipeline, stages\n# Connect to MongoDB\nMONGODB_URI = \"mongodb://localhost:27017\"\nclient = pymongo.MongoClient(MONGODB_URI)\ndb = client[\"sample_mflix\"]\n# Create individual stage instances\nmatch_stage = stages.Match(query={\"title\": \"A Star Is Born\"})\nsort_stage = stages.Sort(by=\"year\")\nlimit_stage = stages.Limit(value=1)\n# Combine stages into a pipeline\npipeline_stages = [match_stage, sort_stage, limit_stage]\npipeline = Pipeline(stages=pipeline_stages)\n# Execute the pipeline\ncursor = db[\"movies\"].aggregate(pipeline.export())\nresults = list(cursor)\nprint(results)\n</code></pre> <p>This approach offers advantages: - \ud83d\udd04 Stages can be reused across multiple pipelines - \ud83d\udd00 Stages can be easily reordered or modified - \ud83e\udde9 Complex stage configurations can be built separately</p>"},{"location":"tutorial/pipeline/#complex-example-analysis-pipeline","title":"\ud83c\udf1f Complex Example: Analysis Pipeline","text":"<p>Here's a more comprehensive example that analyzes movies by genre:</p> Analysis Pipeline<pre><code>import pymongo\nfrom monggregate import Pipeline, S\n# Connect to MongoDB\nclient = pymongo.MongoClient(\"mongodb://localhost:27017\")\ndb = client[\"sample_mflix\"]\n# Build an analysis pipeline\npipeline = Pipeline()\npipeline.match(\nyear={\"$gte\": 2000}  # Movies from 2000 onwards\n).unwind(\npath=\"genres\"  # Split documents by genre\n).group(\nby=\"genres\",  # Group by genre\nquery={\n\"count\": S.sum(1),  # Count movies per genre\n\"avg_imdb\": S.avg(\"$imdb.rating\"),  # Average IMDB rating\n\"titles\": S.push(\"$title\")  # Collect titles\n}\n).match(\ncount=S.gt(10)  # Only include genres with &gt;10 movies\n).sort(\nby=\"avg_imdb\",\ndescending=True\n)\n# Execute the pipeline\nresults = list(db[\"movies\"].aggregate(pipeline.export()))\nfor genre in results:\nprint(f\"{genre['_id']}: {genre['count']} movies, {genre['avg_imdb']:.2f} avg rating\")\n</code></pre>"},{"location":"tutorial/pipeline/#pipeline-manipulation","title":"\ud83d\udee0\ufe0f Pipeline Manipulation","text":"<p>\ud83d\udcda The <code>Pipeline</code> class implements Python's list interface, allowing you to manipulate stages programmatically:</p> Pipeline Manipulation<pre><code># Check pipeline length\nprint(len(pipeline))  # Returns number of stages\n# Add a stage to the end\npipeline.append(stages.Project(title=1, year=1))\n# Add multiple stages\npipeline.extend([\nstages.Skip(10),\nstages.Limit(5)\n])\n# Insert a stage at a specific position\npipeline.insert(0, stages.Match(year=2020))\n</code></pre> <p>This makes pipelines highly flexible and enables dynamic pipeline construction based on conditions or user input.</p>"},{"location":"tutorial/pipeline/#next-steps","title":"\ud83d\udd1c Next Steps","text":"<ul> <li>\ud83d\udd04 Learn about available aggregation stages</li> <li>\ud83d\udee0\ufe0f Explore MongoDB operators for advanced data manipulation</li> <li>\ud83d\udd0d Discover vector search capabilities for similarity queries</li> </ul>"},{"location":"tutorial/search/","title":"\ud83d\udd0d Atlas Search in Monggregate","text":"<p>MongoDB's aggregation framework provides powerful search capabilities through the <code>$search</code> and <code>$searchMeta</code> stages, available exclusively with MongoDB Atlas. Monggregate makes these advanced search features accessible through an intuitive Python interface.</p>"},{"location":"tutorial/search/#what-is-atlas-search","title":"\ud83d\udccb What is Atlas Search?","text":"<p>\ud83d\udca1 Atlas Search integrates full-text search capabilities directly into your MongoDB database, providing functionality similar to dedicated search engines like Elasticsearch or Algolia.</p> <p>Atlas Search offers:</p> <ul> <li>\ud83d\udd24 Full-text search with language-aware text analysis</li> <li>\ud83d\udd04 Fuzzy matching to handle typos and misspellings</li> <li>\u270f\ufe0f Autocomplete suggestions for partial queries</li> <li>\u2b50 Relevance scoring to rank results by importance</li> <li>\ud83d\udd06 Highlighting to emphasize matching terms</li> <li>\ud83d\udcca Faceting for categorizing and filtering results</li> <li>\ud83c\udf0d Geospatial search for location-based queries</li> <li>\ud83e\udde0 Vector search for semantic similarity and AI applications</li> </ul> <p>\ud83d\udcda For a complete feature list, see the Atlas Search documentation.</p>"},{"location":"tutorial/search/#basic-search-queries","title":"\ud83d\udd30 Basic Search Queries","text":"<p>Creating a basic search query with Monggregate is straightforward:</p> <pre><code>from monggregate import Pipeline\npipeline = Pipeline()\npipeline.search(\npath=\"description\",  # Field to search in\nquery=\"apple\"        # Search term\n)\n</code></pre> <p>\ud83d\udcd8 By default, Monggregate uses the <code>text</code> operator for search queries. This query will find all documents containing \"apple\" in the description field.</p>"},{"location":"tutorial/search/#adding-fuzzy-matching","title":"\u2728 Adding Fuzzy Matching","text":"<p>To handle typos and minor spelling variations, add fuzzy matching:</p> <pre><code>from monggregate import Pipeline\nfrom monggregate.search.commons import FuzzyOptions\npipeline = Pipeline()\npipeline.search(\npath=\"description\",\nquery=\"apple\",\nfuzzy=FuzzyOptions(\nmax_edits=2  # Allow up to 2 character edits\n)\n)\n</code></pre> <p>\ud83d\udd0d This query will match terms like \"appl\", \"appel\", or \"aple\" in addition to \"apple\".</p>"},{"location":"tutorial/search/#advanced-search-with-operators","title":"\ud83d\udee0\ufe0f Advanced Search with Operators","text":"<p>Atlas Search provides several specialized operators for different search needs:</p>"},{"location":"tutorial/search/#text-search","title":"\ud83d\udcdd Text Search","text":"<pre><code>pipeline = Pipeline()\npipeline.search(\noperator_name=\"text\",  # Explicitly specify text operator\npath=\"plot\",\nquery=\"space adventure\",\nfuzzy=FuzzyOptions(max_edits=1)\n)\n</code></pre>"},{"location":"tutorial/search/#autocomplete","title":"\u270f\ufe0f Autocomplete","text":"<pre><code>pipeline = Pipeline()\npipeline.search(\noperator_name=\"autocomplete\",\npath=\"title\",\nquery=\"star w\",      # Will match \"Star Wars\"\nfuzzy=FuzzyOptions(max_edits=1)\n)\n</code></pre>"},{"location":"tutorial/search/#regex-search","title":"\ud83d\udd23 Regex Search","text":"<pre><code>pipeline = Pipeline()\npipeline.search(\noperator_name=\"regex\",\npath=\"email\",\nquery=\"^john\\\\.[a-z]+@example\\\\.com$\"  # Match specific email pattern\n)\n</code></pre>"},{"location":"tutorial/search/#compound-search-queries","title":"\ud83e\udde9 Compound Search Queries","text":"<p>\ud83d\udca1 The real power of Atlas Search emerges with compound queries that combine multiple search conditions.</p> <p>The <code>compound</code> operator supports four types of clauses:</p> <ul> <li>\ud83d\udd12 must: Documents MUST match these conditions AND they affect relevance score</li> <li>\ud83d\udd0d filter: Documents MUST match these conditions but they DON'T affect relevance score</li> <li>\u2b50 should: Documents SHOULD match these conditions and they affect relevance score</li> <li>\ud83d\udeab mustNot: Documents MUST NOT match these conditions</li> </ul>"},{"location":"tutorial/search/#building-compound-queries","title":"\ud83c\udfd7\ufe0f Building Compound Queries","text":"<p>Monggregate provides a unique \"search pipeline\" approach for building compound queries:</p> <pre><code>pipeline = Pipeline()\n# Initialize a compound search\npipeline.search(\nindex=\"movies\",           # Search index name\noperator_name=\"compound\"\n).search(                     # Add a \"must\" clause\nclause_type=\"must\", \nquery=\"adventure\",\npath=\"genres\"\n).search(                     # Add a \"should\" clause\nclause_type=\"should\",\nquery=\"space\",\npath=\"plot\"\n).search(                     # Add a \"mustNot\" clause\nclause_type=\"mustNot\",\nquery=\"horror\",\npath=\"genres\"\n)\n</code></pre> <p>This query will: 1. \ud83d\udd12 REQUIRE documents to have \"adventure\" in the genres field 2. \u2b50 PREFER documents with \"space\" in the plot (boosting relevance score) 3. \ud83d\udeab EXCLUDE documents with \"horror\" in the genres field</p> <p>The resulting MongoDB aggregation will look like:</p> <pre><code>[\n{\n\"$search\": {\n\"index\": \"movies\",\n\"compound\": {\n\"must\": {\n\"text\": {\n\"query\": \"adventure\",\n\"path\": \"genres\"\n}\n},\n\"should\": {\n\"text\": {\n\"query\": \"space\",\n\"path\": \"plot\"\n}\n},\n\"mustNot\": {\n\"text\": {\n\"query\": \"horror\",\n\"path\": \"genres\"\n}\n}\n}\n}\n}\n]\n</code></pre>"},{"location":"tutorial/search/#faceted-search-with-searchmeta","title":"\ud83d\udcca Faceted Search with searchMeta","text":"<p>\ud83d\udcd8 Faceted search allows users to filter and navigate search results by categories or attributes.</p> <p>Use the <code>search_meta</code> stage to implement faceting:</p> <pre><code>pipeline = Pipeline()\n# Initialize a faceted search\npipeline.search_meta(\nindex=\"movies\",\ncollector_name=\"facet\"\n).search_meta(               # Add string facet on genres\nfacet_type=\"string\",\npath=\"genres\",\nnum_buckets=10           # Return top 10 genres\n).search_meta(               # Add numeric facet on year\nfacet_type=\"number\",\npath=\"year\",\nboundaries=[1970, 1980, 1990, 2000, 2010, 2020]\n)\n</code></pre> <p>This creates a faceted search that: 1. \ud83d\udccb Groups movies by genre, showing the top 10 most common genres 2. \ud83d\udcc5 Splits movies into date ranges (pre-1970, 1970s, 1980s, etc.)</p>"},{"location":"tutorial/search/#combining-search-and-facets","title":"\ud83d\udd17 Combining Search and Facets","text":"<p>You can combine regular search with faceting to create powerful filtered search experiences:</p> <pre><code>pipeline = Pipeline()\n# First define search criteria\npipeline.search_meta(\nindex=\"movies\",\noperator_name=\"text\",\npath=\"plot\",\nquery=\"space\"\n# Then add faceting\n).search_meta(\ncollector_name=\"facet\"\n).search_meta(\nfacet_type=\"string\",\npath=\"genres\"\n)\n</code></pre> <p>\ud83d\udd0d This will search for \"space\" in movie plots, then return facet counts showing which genres are most common in the results.</p>"},{"location":"tutorial/search/#complete-search-example","title":"\ud83c\udf1f Complete Search Example","text":"<p>Here's a comprehensive example that combines multiple search features:</p> <pre><code># Create search pipeline\npipeline = Pipeline()\npipeline.search(\nindex=\"default\",\noperator_name=\"compound\"\n).search(\n# Movies must be from the 2000s\nclause_type=\"filter\",\noperator_name=\"range\",\npath=\"year\",\ngte=2000,\nlte=2009\n).search(\n# Movies should contain \"future\" in plot\nclause_type=\"should\",\noperator_name=\"text\",\npath=\"plot\",\nquery=\"future\",\nscore={\"boost\": {\"value\": 3}}  # Boost relevance\n).search(\n# Movies should contain \"technology\" in plot\nclause_type=\"should\",\noperator_name=\"text\",\npath=\"plot\",\nquery=\"technology\"\n).limit(10).project(\ntitle=1,\nyear=1,\nplot=1,\nscore={\"$meta\": \"searchScore\"}  # Include relevance score\n)\n# Execute the pipeline\nresults = list(db.movies.aggregate(pipeline.export()))\nfor movie in results:\nprint(f\"{movie['title']} ({movie['year']}) - Score: {movie['score']:.2f}\")\n</code></pre>"},{"location":"tutorial/search/#next-steps","title":"\ud83d\udd1c Next Steps","text":"<ul> <li>\ud83e\udde0 Learn about vector search capabilities for semantic search and AI applications</li> <li>\ud83d\udee0\ufe0f Explore the full range of MongoDB operators for additional data manipulation</li> <li>\ud83d\udd04 Understand how to build complex aggregation pipelines combining search with other stages</li> </ul>"},{"location":"tutorial/stages/","title":"\ud83d\udd04 MongoDB Aggregation Stages","text":"<p>Stages are the building blocks of aggregation pipelines.</p> <p>\ud83d\udcd8 We saw in the previous page two methods to compose stages to effectively build a pipeline:</p> <ul> <li>Using the pipeline stages methods</li> <li>Using the stages classes directly</li> </ul> <p>Repeating what was described previously:</p> <p>\ud83d\udca1 Each stage of the aggregation framework also has its own class in the package. And each <code>Stage</code> class has a mirror method in the <code>Pipeline</code>.</p> <p>There is actually an asterisk to this. Monggregate does not yet provide an interface to all of the stages provided by MongoDB. It is a work in progress and the list of available stages will grow over time. If you want to contribute, please refer to the contributing guide.</p> <p>You can see the full list of stages provided by MongoDB here.</p>"},{"location":"tutorial/stages/#list-of-available-stages-in-monggregate","title":"\ud83d\udccb List of Available Stages In Monggregate","text":"<p>The following table lists the stages that are currently available in Monggregate:</p> <ul> <li><code>$addFields</code></li> <li><code>$bucket</code></li> <li><code>$bucketAuto</code></li> <li><code>$count</code></li> <li><code>$group</code></li> <li><code>$limit</code></li> <li><code>$lookup</code></li> <li><code>$match</code></li> <li><code>$merge</code></li> <li><code>$out</code></li> <li><code>$project</code></li> <li><code>$replaceRoot</code></li> <li><code>$replaceWith</code></li> <li><code>$sample</code></li> <li><code>$search</code></li> <li><code>$searchMeta</code></li> <li><code>$set</code></li> <li><code>$skip</code></li> <li><code>$sort</code></li> <li><code>$sortByCount</code></li> <li><code>$unionWith</code></li> <li><code>$unset</code></li> <li><code>$unwind</code></li> </ul>"},{"location":"tutorial/stages/#usage","title":"\ud83d\ude80 Usage","text":"<p>\ud83c\udfaf <code>monggregate</code> aims at providing a simple and intuitive interface to the MongoDB aggregation framework.</p> <p>Even though, it tries as much as possible to stick by the MongoDB aggregation framework syntax, it also tries to provide alternative ways to reproduce the syntax of other tools that new Mongo users might be more familiar with such as SQL and Pandas.</p> <p>For example, in the <code>$group</code> stage, the MongoDB aggregation framework expects the grouping field(s) to be provided in the <code>_id</code> key. However, <code>monggregate</code> allows you to provide the grouping field(s) in the <code>by</code> key instead.</p> <pre><code>pipeline = Pipeline()\npipeline.group(\nby=\"year\",\nquery={\n\"movie_count\": {\"$sum\": 1},\n\"movie_titles\": {\"$push\": \"$title\"}\n}\n)\n</code></pre> <p>Similarly, <code>monggregate</code> pipeline <code>lookup</code> method and <code>Lookup</code> class provide aliases for the orignal MongoDB arguments:</p> MongoDB Original Name Monggregate Original Name Monggregate Convenient Alias from from right localField local_field left_on foreignField foreign_field right_on as as name <p>\u2139\ufe0f Note: The original names of the arguments were converted to snake_case to follow the Python convention. You cannot use the camelCase version of the arguments names here.</p> <p>You can therefore use any combination of arguments names from the two rightmost columns above to build your stage.</p> <pre><code>pipeline = Pipeline()\npipeline.lookup(\nright = \"comments\", # collection to join\nleft_on = \"_id\",  # primary key\nright_on = \"movie_id\", # foreign key\n# name of the field that will contain the matching documents\nname = \"related_comments\" \n)\n</code></pre> <p>When using the stages methods, you can sometimes omit to name the argument(s). We can for example complete the previous example as follows:</p> <pre><code>pipeline = Pipeline()\npipeline.lookup(\nright = \"comments\", \nleft_on = \"_id\", \nright_on = \"movie_id\",\nname = \"related_comments\" \n).sort(\n\"movie_count\"\n).limit(\n10\n)\n</code></pre> <p>\ud83d\udd0d The arguments names (<code>by</code> and <code>value</code> respectively) for the <code>sort</code> and <code>limit</code> stages are omitted.</p> <p>\ud83d\udca1 Note: Just as the <code>Pipeline</code> class provides methods for all stages, the <code>S</code> (Dollar) object provides methods for all MongoDB operators. They serve similar roles in different contexts - <code>Pipeline</code> for constructing aggregation sequences, and <code>S</code> for building expressions with operators. For more details on the <code>S</code> object, see the Operators documentation.</p>"},{"location":"tutorial/stages/#operators","title":"\ud83d\udee0\ufe0f Operators","text":"<p>You might have noticed in the grouping example how we tell Monggregate to perform operations on the groups. In the example, we used the <code>$sum</code> and <code>$push</code> operators.</p> <p>\ud83d\udd1c For more information about operators, check the next page.</p>"},{"location":"tutorial/vector-search/","title":"\ud83d\udd0d Vector Search with Monggregate","text":"<p>MongoDB Atlas provides powerful vector search capabilities through the <code>$vectorSearch</code> stage, enabling approximate nearest neighbor (aNN) search on vector embeddings. Monggregate makes these advanced vector search features accessible through an intuitive Python interface.</p>"},{"location":"tutorial/vector-search/#what-is-vector-search","title":"\ud83d\udccb What is Vector Search?","text":"<p>\ud83d\udca1 Vector search allows you to find documents with similar vector embeddings to a query vector, enabling semantic search, recommendations, and AI-powered applications.</p> <p>Atlas Vector Search offers:</p> <ul> <li>\ud83e\udde0 Semantic similarity search using vector embeddings</li> <li>\ud83d\udd0d Approximate nearest neighbor (aNN) algorithms for efficient vector comparison</li> <li>\u26a1 Fast retrieval of similar items from large collections</li> <li>\ud83e\udde9 Pre-filtering to narrow search scope and improve relevance</li> <li>\ud83d\udd04 Integration with AI models like OpenAI, Hugging Face, and others</li> </ul> <p>\ud83d\udcda Vector search is particularly useful for applications like: - Semantic text search that understands meaning, not just keywords - Image similarity search - Recommendation systems - AI-powered chatbots and RAG (Retrieval Augmented Generation)</p>"},{"location":"tutorial/vector-search/#prerequisites-for-vector-search","title":"\ud83d\udd30 Prerequisites for Vector Search","text":"<p>Before using vector search with Monggregate, you need to:</p> <ol> <li>\ud83d\udcca Create an Atlas Vector Search index on your collection</li> <li>\ud83e\uddea Generate vector embeddings for your documents using an embedding model</li> <li>\ud83d\udcbe Store these embeddings in your MongoDB documents</li> </ol> <p>\u26a0\ufe0f Vector search is only available on MongoDB Atlas clusters running v6.0.11 or v7.0.2 and later.</p>"},{"location":"tutorial/vector-search/#basic-vector-search","title":"\ud83d\ude80 Basic Vector Search","text":"<p>Creating a vector search query with Monggregate is straightforward:</p> <pre><code>from monggregate import Pipeline\n# Generate or obtain your query vector (embedding)\nquery_vector = [0.1, 0.2, 0.3, 0.4, ...]  # Your vector dimensions here\n# Build the vector search pipeline\npipeline = Pipeline()\npipeline.vector_search(\nindex=\"vector_index\",        # Name of your Atlas Vector Search index\npath=\"embedding\",            # Field containing vector embeddings\nquery_vector=query_vector,   # Your search vector\nnum_candidates=100,          # Number of candidates to consider\nlimit=10                     # Number of results to return\n)\n</code></pre> <p>\ud83d\udcd8 This query will find the 10 documents whose embedding vectors are most similar to your query vector, considering 100 nearest neighbors during the search.</p>"},{"location":"tutorial/vector-search/#filtering-vector-search-results","title":"\ud83d\udd0d Filtering Vector Search Results","text":"<p>You can narrow your vector search with filters:</p> <pre><code>from monggregate import Pipeline\npipeline = Pipeline()\npipeline.vector_search(\nindex=\"product_embeddings\",\npath=\"product_vector\",\nquery_vector=query_vector,\nnum_candidates=200,\nlimit=20,\nfilter={\n\"category\": \"electronics\",\n\"price\": {\"$lt\": 1000}\n}\n)\n</code></pre> <p>\ud83d\udd0d This search will only consider products in the \"electronics\" category with a price less than 1000.</p>"},{"location":"tutorial/vector-search/#retrieving-search-scores","title":"\ud83c\udf1f Retrieving Search Scores","text":"<p>To include the similarity score in your results:</p> <pre><code>pipeline = Pipeline()\npipeline.vector_search(\nindex=\"text_embeddings\",\npath=\"content_vector\",\nquery_vector=query_vector,\nnum_candidates=150,\nlimit=10\n).project(\ncontent=1,\nmetadata=1,\nscore={\"$meta\": \"vectorSearchScore\"}  # Include the vector similarity score\n)\n</code></pre> <p>\ud83d\udcaf Atlas Vector Search assigns a score between 0 and 1 to each result, with higher scores indicating greater similarity.</p>"},{"location":"tutorial/vector-search/#complete-example-semantic-search","title":"\ud83d\udcdd Complete Example: Semantic Search","text":"<p>Here's a comprehensive example that uses vector search for a semantic search application:</p> <pre><code>import numpy as np\nfrom sentence_transformers import SentenceTransformer\nfrom monggregate import Pipeline\nimport pymongo\n# Connect to MongoDB\nclient = pymongo.MongoClient(\"mongodb+srv://...\")\ndb = client[\"knowledgebase\"]\n# Load embedding model\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\n# Generate embedding for user query\nuser_query = \"How do I implement authentication in my application?\"\nquery_embedding = model.encode(user_query).tolist()\n# Create vector search pipeline\npipeline = Pipeline()\npipeline.vector_search(\nindex=\"document_vectors\",\npath=\"embedding\",\nquery_vector=query_embedding,\nnum_candidates=100,\nlimit=5,\nfilter={\n\"document_type\": \"article\",\n\"status\": \"published\"\n}\n).project(\ntitle=1,\ncontent=1,\nurl=1,\nscore={\"$meta\": \"vectorSearchScore\"}\n)\n# Execute search\nresults = list(db.documents.aggregate(pipeline.export()))\n# Display results\nfor doc in results:\nprint(f\"Title: {doc['title']}\")\nprint(f\"Score: {doc['score']:.4f}\")\nprint(f\"URL: {doc['url']}\")\nprint(\"-\" * 40)\n</code></pre>"},{"location":"tutorial/vector-search/#technical-details","title":"\ud83d\udd2c Technical Details","text":"<ul> <li>\ud83d\udd22 Vector dimensions: Your query vector must have the same number of dimensions as the vectors in your indexed field</li> <li>\ud83c\udfaf numCandidates: Should be greater than the limit for better accuracy, typically 10-20x for optimal recall</li> <li>\u26a1 Performance tuning: Adjust numCandidates to balance between search quality and speed</li> <li>\ud83d\udd04 Filtering: Only works on indexed fields marked as the \"filter\" type in your vector search index</li> <li>\ud83d\udcca Scoring: For cosine and dotProduct similarities, scores are normalized using the formula: <code>score = (1 + cosine/dot_product(v1,v2)) / 2</code></li> </ul>"},{"location":"tutorial/vector-search/#next-steps","title":"\ud83d\udd1c Next Steps","text":"<ul> <li>\ud83d\udee0\ufe0f Explore the full range of MongoDB operators for additional data manipulation</li> <li>\ud83d\udd04 Learn how to build complex aggregation pipelines combining vector search with other stages</li> <li>\ud83d\udd0d Discover Atlas Search capabilities for traditional text search and faceting</li> </ul>"}]}